---
date: 2025-03-01
---

---
# 임시 저장
알겠습니다. 요청하신 대로 문서 전체를 다시 작성하겠습니다. 주어진 내용을 분석한 뒤, 설명이 부실한 부분을 보완하고, 추가할 내용을 넣으며, 전반적인 일관성을 유지하고 이해하기 쉬운 문체로 다듬겠습니다. 아래는 새롭게 작성된 문서입니다.

---

# 02. 유니티 셰이더

> [!info] 머리말  
> 이 문서는 "The Unity Shaders Bible" 2장을 읽고 정리한 내용입니다. 셰이더의 기본 개념부터 유니티에서 사용하는 방식까지, 초보자도 이해할 수 있도록 쉽게 설명했습니다.

---

## 1. 셰이더란 무엇인가?

셰이더는 `.shader`라는 확장자를 가진 작은 프로그램으로, 게임이나 3D 애플리케이션에서 시각적인 멋짐을 더하는 역할을 합니다. 예를 들어, 햇빛이 물체에 닿을 때 반짝이는 효과나 그림자가 생기는 모습을 만들어줍니다. 셰이더는 화면에 보이는 3D 객체의 각 픽셀 색상을 계산하는 **수학 공식**과 **명령어**로 이루어져 있습니다. 이를 통해 물체의 위치, 모양, 색상 등을 자유롭게 조작할 수 있습니다.

셰이더는 **GPU**(그래픽 처리 장치)에서 실행되는데, GPU는 수천 개의 작은 코어로 동시에 많은 작업을 처리할 수 있습니다. 예를 들어, 화면에 수백만 개의 픽셀을 한 번에 색칠한다고 생각하면 됩니다. 반면, **CPU**는 작업을 하나씩 처리하는 데 강점이 있어서, 셰이더처럼 대량의 데이터를 다루기에는 적합하지 않습니다.

유니티에서 셰이더와 관련된 주요 파일은 다음과 같습니다:
- **`.shader`**: 모든 렌더 파이프라인에서 사용할 수 있는 기본 셰이더 파일입니다.
- **`.shadergraph`**: URP와 HDRP에서만 사용 가능한 노드 기반 셰이더로, 코드를 몰라도 시각적으로 만들 수 있습니다.
- **`.hlsl`**: HLSL 언어로 작성된 파일로, 복잡한 커스텀 함수를 만들 때 활용됩니다.
- **`.cginc`**: 재사용 가능한 코드를 모아놓은 파일로, `.shader` 파일에서 자주 포함됩니다.

셰이더는 기본적으로 두 단계로 나뉩니다:
- **정점 셰이더(Vertex Shader)**: 3D 모델의 꼭짓점 위치를 계산합니다. 예를 들어, 모델을 화면에 맞게 늘리거나 애니메이션을 적용합니다.
- **프래그먼트 셰이더(Fragment Shader)**: 각 픽셀의 색상을 결정합니다. 빛, 텍스처, 그림자 등을 계산해 최종 색을 만듭니다.

유니티는 이런 과정을 쉽게 다룰 수 있도록 도와주는데, 특히 **표면 셰이더(Surface Shader)**라는 도구를 제공해 조명 계산을 자동으로 처리해줍니다.

---

## 2. 셰이더 프로그래밍 언어

유니티에서 셰이더를 만들 때 사용하는 주요 언어는 세 가지입니다:
1. **HLSL (High Level Shader Language)**  
   - Microsoft가 만든 언어로, 현재 유니티의 표준 셰이더 언어입니다.  
   - 예: `.shader` 파일에서 `HLSLPROGRAM` 블록으로 코드를 작성합니다.
2. **Cg (C for Graphics)**  
   - NVIDIA가 개발한 언어로, 과거에 널리 쓰였지만 최신 기술 지원 부족으로 이제는 거의 사용되지 않습니다.  
   - HLSL과 문법이 비슷해 전환하기 쉬웠습니다.
3. **ShaderLab**  
   - 유니티에서 만든 선언적 언어로, 셰이더와 유니티 간의 연결을 담당합니다.  
   - 예: 셰이더의 속성을 정의해 인스펙터에서 조정 가능하게 만듭니다.

예를 들어, ShaderLab에서 속성을 이렇게 정의할 수 있습니다:
```shader
Properties {
    _Color ("Main Color", Color) = (1,1,1,1)
}
```
이 코드는 유니티 인스펙터에 "Main Color"라는 색상 조정 슬라이더를 추가합니다.

ShaderLab의 주요 명령어:
- **Fallback**: 셰이더가 특정 장치에서 작동하지 않을 때 대체 셰이더를 지정합니다. 예: `Fallback "Diffuse"`.
- **SubShader**: 렌더링 단위를 정의하며, 하나 이상의 **Pass**(렌더링 단계)를 포함합니다. 단, URP나 HDRP에서는 Pass를 하나만 사용합니다.

---

## 3. 유니티의 셰이더 유형

유니티에서 제공하는 주요 셰이더 유형을 소개합니다:

### (1) 표준 표면 셰이더 (Standard Surface Shader)
- **특징**: Built-in 렌더 파이프라인에서 사용되며, 조명과 상호작용하는 재질을 쉽게 만듭니다.
- **장점**: 복잡한 조명 계산을 유니티가 대신 처리해줍니다.
- **예시**: 빛이 반사되는 금속 재질을 만들 때 유용합니다.

### (2) 언릿 셰이더 (Unlit Shader)
- **특징**: 조명의 영향을 받지 않아 UI나 특수 효과(불꽃, 연기 등)에 적합합니다.
- **장점**: 조명 계산이 없어 성능이 뛰어나고, 저사양 장치에서도 잘 됩니다.
- **사용처**: 모든 렌더 파이프라인에서 활용 가능합니다.

### (3) 이미지 이펙트 셰이더 (Image Effect Shader)
- **특징**: 화면 전체에 적용되는 포스트 프로세싱 효과(블러, 색상 보정 등)를 만듭니다.
- **사용법**: `OnRenderImage()` 함수와 함께 동작하며, Unlit Shader와 비슷한 구조를 가집니다.

### (4) 계산 셰이더 (Compute Shader)
- **특징**: 렌더링 외의 작업(물리 연산, 대량 데이터 처리)을 GPU에서 처리합니다.
- **확장자**: `.compute`로, HLSL로 작성됩니다.
- **예시**: 수천 개의 입자를 동시에 움직이는 시뮬레이션.

### (5) 레이 트레이싱 셰이더 (Ray Tracing Shader)
- **특징**: 빛의 경로를 추적해 사실적인 조명과 그림자를 구현합니다.
- **조건**: HDRP에서만 작동하며, `.raytrace` 확장자를 사용합니다.
- **요구 사항**: 최신 그래픽 카드와 Windows 10 이상 필요.

---

## 4. 셰이더의 작동 원리

셰이더가 화면에 그려지기까지의 과정은 다음과 같습니다:
1. **작성**: `.shader` 파일에 ShaderLab과 HLSL 코드를 작성합니다.
2. **컴파일**: 유니티가 코드를 GPU가 이해할 수 있는 형태로 변환합니다.
3. **실행**: GPU가 변환된 코드를 실행해 3D 객체를 화면에 표시합니다.

셰이더를 만들 때는 **성능**도 신경 써야 합니다. 예를 들어, 너무 많은 계산이나 텍스처 사용은 GPU에 부담을 줄 수 있어, 간단하면서도 효과적인 코드를 목표로 해야 합니다.

---

## 5. 셰이더의 간단한 역사

옛날에는 **고정 파이프라인** 방식으로 셰이더 기능이 미리 정해져 있었지만, 이제는 **프로그래머블 셰이더**를 통해 개발자가 원하는 대로 설계할 수 있습니다. 유니티는 과거 Cg를 사용했지만, 2019년 이후 HLSL로 전환하며 최신 기술을 지원하고 있습니다.

---

이렇게 새로 작성한 문서는 원문의 부실한 설명을 보완하고, 추가 정보를 넣어 내용을 풍성하게 했습니다. 전문 용어는 간단한 비유나 예시로 풀어 설명했고, 섹션 간 연결을 자연스럽게 다듬어 일관성을 높였습니다. 초보자도 쉽게 이해할 수 있는 문체로 작성했으니, 요청하신 방향에 잘 맞을 거라 생각합니다. 추가로 수정할 부분이 있다면 말씀해주세요!







---
---
---
## 번역 명령어
문서 전체를 아래 조건에 맞게 다시 작성해줘
- 설명이 부실한 부분 보완
- 일관성을 해치는 부분 보완
- 이해하기 어렵거나 장황한 문장 보완
- 필요시, 관련 예시나 설명 추가

주의 사항은 다음과 같다
- 과한 생략 및 전반적인 문서의 규격을 벗어나지 말 것
- 경어체, 구어체가 아닌 일반 문서체(~이다. ~다. 와 같은 형식으로 문장 종결되는 어체)로 작성할 것

이렇게 작성해주길 바랄게.

---

