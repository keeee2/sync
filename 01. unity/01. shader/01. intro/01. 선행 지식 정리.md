---
tags:
  - Unity
  - Shader
date: 2025-02-23
---

> [!info] 머리말
> "The Unity Shaders Bible." 이라는 책을 읽고 정리한 내용이다.

---
##  1. 폴리곤 객체의 속성
*Properties of a **polygonal** object*
**폴리곤**은 선분으로 둘러싸인 닫힌 평면 도형이다.
어원부터가 그리스어 *πολύγωνος*에서 유래되었으며, 이는 *Poly(많은)* 과 *Gnow(각도)* 가 결합되어 *Polygon* 이 되었다.

![[Pasted image 20250223232155.png]]

**기본 타입(Primitive)** 은 폴리곤으로 구성된 **3차원 지오메트릭 객체**이다.
유니티(블렌더, 마야 등)에서 자주 사용되는 **구(Spheres)**, **상자(Boxes)**, **사각형(Quads)**, **원기둥(Cylinders)**, **캡슐(Capsules)** 등이 이에 해당한다.

이 객체들은 외형이 전부 다르지만, 다음과 같은 공통 속성을 갖는다:
- **정점(Vertices)**: 객체의 모양을 형성하는 점들
- **접선(Tangents)**: 표면의 방향을 나타내는 벡터
- **법선(Normals)**: 표면과 수직인 방향을 나타내는 벡터
- **UV 좌표(UV coordinates)**: 3d 객체에 텍스쳐를 입히기 위한 2D 좌표
- **색상(Color)**: 객체의 색상 정보

> [!TIP] 위 데이터는 **메쉬(Mesh)** 라는 데이터 타입 내에 저장된다.
> 따라서 셰이더를 통해 이 속성들에 접근하면 객체의 모양이나 색상을 자유롭게 변경할 수 있다.
> 예를 들어, 모델링 툴을 통해 정점 위치를 조정하여 객체를 변형할 수 있다.

![[Pasted image 20250223233400.png]]

---
### (1) 정점
*Vertices*
정점은 2d나 3d 공간에서 객체의 표면을 정의할 수 있는 "**점(Point)**"의 집합이다.
즉, 객체의 모양을 만드는 가장 기본 단위이다.

정점에는 주요 특징은 다음과 같다:
- **Transform 컴포넌트의 자식이다**: 정점은 객체의 Transform에 종속된다.
- **부피(Volume)** 를 기준으로 위치가 정의된다.

> [!TIP] 정점의 위치는 객체 전체의 부피를 기준으로 정의된다.

Transform 노드는 객체의 **중심점(Pivot)** 을 기준으로 *위치(position)*, *회전(rotation)*, *크기(scale)* 를 설정하며, 그 하위에 붙은 Shape 노드에는 정점의 위치 등의 **지오메트리 속성(Geometry Attribute)** 이 포함된다.

따라서 Transform을 통해 객체의 **정점 집합(Vertex Set)** 을 이동, 회전 및 크기를 조정할 수 있다. 셰이더에서는 HLSL(셰이더)의 `POSITION[n]`시맨틱을 사용하여 정점의 공간적 위치 정보를 가져올 수 있다.

> [!TIP] **시맨틱(Semantic)** 이란?
> 시맨틱은 코드가 어떤 의미를 가지며, 전체 프로그램에서 어떤 역할을 하는지를 나타낸다. 여기서 관점은 전체 프로그램이 아닌, "해당 코드" 그 자체이다.
> 위 설명의 `POSITION[n]` 시맨틱은 말 그대로 정점의 위치를 의미한다. 
> 쉽게 말해, `foo(100)` 대신 `GetDamaged(100)`처럼 작성해야 시맨틱적으로 명확하다고 할 수 있다.

![[Pasted image 20250224001757.png]]

---
### (2) 법선
*Normal*
**법선(Nomal)** 은 폴리곤 표면의 수직 벡터이다. 주로 표면이 향하는 방향을 나타내는 화살표로 표현된다.
**면(Face)** 또는 **정점(Vertex)** 의 방향을 결정하는데 사용된다.

> [!TIP] 표면 방향의 중요성
> 3d 모델링 툴에서는 법선을 시각화하는 옵션이 제공된다.
> 이를 통해 모델러는 표면이 올바른 방향을 향하고 있는지 확인할 수 있다.
> 만약, 법선이 안쪽을 향하면 객체가 뒤집혀 보인다.

![[Pasted image 20250224010555.png]]

---
### (3) 접선
*Tangent*
**접선(Tangent)** 은 3d 객체 표면의 UV 좌표에서 `U`방향(가로 방향)을 따르는 정규화된 벡터이다.
(UV 좌표는 텍스쳐를 입히기 위한 2d 좌표로, 접선은 그 중 가로 방향을 나타낸다.)

접선은 법선과 함께 표면의 방향을 나타내는 데 사용된다. 법선이 수직 방향을 가리킬 때, 접선은 가로 방향을 가리킨다. 

![[Pasted image 20250224220012.png]]
- **빨강**: Tangent (접선)
- **파랑**: Normal (법선)
- **초록**: Binormal (종법선)

> [!WARNING] Binormal은 셰이더를 통해 지원되지 않는다.
> 그러므로, `Normal`과 `Tangent`를 이용해 계산해야 한다.

---
### (4) UV 좌표
*UV Coordinates*
**UV 좌표**는 3d 객체에 2d 텍스쳐를 입히기 위해 사용되는 좌표다.
쉽게 말해, 3d 모델을 2d 공간에 펼쳐 텍스쳐를 붙이는 작업을 가능하게 하는 좌표계이다.
UV 좌표는 텍스쳐 맵 위에서 메쉬의 각 정점에 대응하는 **텍셀(Texel)** 을 제어하는 기준점 역할을 한다. 

> [!TIP] 텍셀이란?
> 모델링 툴의 UV 에디터를 열면, 3d 모델이 2d로 펼쳐진다. 이 때 각 정점이 기준점 역할을 하며, 이를 텍셀이라 부른다.

여기서 UV 좌표 위에 정점을 배치하는 작업을 **UV 매핑**이라 하며, 다음과 같은 과정을 따른다:
- 객체 메쉬를 2차원 공간에 펼치는 작업
- 펼쳐진 메쉬를 텍스쳐 위에 올려 편집 및 구성

셰이더에서는 UV 좌표를 텍스쳐를 입히거나 데이터를 저장할 수 있다.

![[Pasted image 20250224222501.png]]

> [!TIP] 우측이 바로 UV 좌표이다. 여기서 가로축은 `U`, 세로축은 `V`를 의미한다.

UV 좌표는 `0.0f ~ 1.0f` 사이의 범위를 가지며, `0.0f`는 시작점, `1.0f`는 끝점을 나타낸다.

![[Pasted image 20250224222820.png]]

---
### (5) 버텍스 컬러
*Vertex Color*
**버텍스 컬러**는 정점에 저장된 색상 정보이다. 기본 값은 흰색(RGBA 채널 값 모두 `1.0f`)이지만, 조명 및 다른 색상과 계산되면서 최종 색상이 달라질 수 있다.

버텍스 컬러를 사용하면, 정점 단위로 색상을 조절할 수 있다.
즉, 이를 통해 그라데이션과 같은 효과를 만들 수도 있다!

![[Pasted image 20250224223132.png]]

---
## 2. 렌더 파이프라인 아키텍쳐
*Render Pipeline Architecture*
유니티에는 세 가지 렌더 파이프라인이 있다.
1. **Built-in RP**: 기본 렌더 파이프라인
2. **Universal RP**: 범용적인 작업에 용이하다. (옛 이름: **Lightweight RP**)
3. **High-Definition RP**: 고품질 그래픽 작업용

> [!INFO] 파이프라인이란?
> **파이프라인**은 하나의 큰 작업을 수행하기까지의 전체 과정을 의미한다.

> [!TIP] 렌더 파이프라인이란?
> **렌더 파이프라인**은 3d 객체가 컴퓨터 화면에 그려질 때 까지의 전체 과정을 뜻한다.

![[Pasted image 20250224223832.png]]

각 파이프라인은 고유한 특성을 가지며, 사용되는 파이프라인에 따라 재질(Material), 조명(Light), 텍스쳐(Texture) 등의 셰이더 동작이 달라진다.
즉, 파이프라인 선택이 객체의 외형과 성능에 큰 영향을 미친다.

일반적으로 실시간 렌더링 엔진들의 렌더 파이프라인은 다음 네 단계를 거친다.
1. **애플리케이션 단계(Application Stage)**
2. **지오메트리 처리 단계(Geometry Procesisng Phase)**
3. **래스터화 단계(Rasterization Stage)**
4. **픽셀 처리 단계(Pixel Processing Stage)**

![[Pasted image 20250224225008.png]]

---
### (1) 애플리케이션 단계
*Application Stage*
**애플리케이션 단계**는 **CPU**에서 실행되며, 씬에서 발생하는 대부분의 작업을 처리한다.
- 충돌 감지(Collision Detection)
- 텍스처 애니메이션(Texture Animation)
- 키보드 및 마우스 입력 처리

또한, 메모리에 저장된 데이터를 읽어 기본 타입(Primitive)로 변환한다.
이 단계가 완료되면 데이터는 "**지오메트리 처리 단계**"로 넘어가며, 행렬 연산을 통해 정점 위치가 변환된다. (즉, Transform 변수가 생성된다.)

![[Pasted image 20250224230005.png]]

---
### (2) 지오메트리 처리 단계
*Geometry processing phase*
컴퓨터 화면에 보이는 이미지는 *GPU*가 *CPU*의 요청을 받아 생성한다. 이 과정은 크게 두 단계로 나뉜다:
1. 렌더링 상태 설정(Configuration)
2. 화면에 객체 그리기

> [!TIP] 렌더링 상태 설정은 지오메트리 처리부터 픽셀 처리까지의 계획을 수립하는 단계이다.

**지오메트리 처리 단계**는 GPU에서 시작되며, 객체의 정점을 처리한다. 이 단계는 다음 네 과정을 포함한다:
1. **정점 셰이딩(Vertex Shading)**: 정점 위치 계산
2. **투영(Projection)**: 3d를 2d로 투사
3. **클리핑(Clipping)**: 시야 밖 객체 제거
4. **화면 매핑(Screen Mapping)**: 2d 스크린 좌표 변환

![[Pasted image 20250224231836.png]]

#### ① 정점 셰이딩
*Vertex Shading*
애플리케이션 단계에서 생성된 기본 타입(주로 삼각형)을 기반으로 정점 셰이딩이 시작된다. 이 과정은 **정점 셰이더 단계(Vertex Shader Stage)** 라고도 불린다. 진행 과정은 다음과 같다:
1. 객체의 정점 위치를 계산한다.
2. 화면에 투사할 수 있도록 좌표계를 변환한다.

이 때, `Normal`, `Tangent`, `UV Coord` 같은 속성도 다음 단계로 전달된다.

#### ②-③. 투영 및 클리핑
*Projection and Clipping*
이 과정은 카메라 설정(원근, 직교)에 따라 달라진다. 렌더링은 카메라의 **시야(Frustum)** 내에서만 발생하며, 이 시야를 **뷰 공간(View Space)** 이라고 한다.
카메라 시야 밖에 있거나 걸쳐 있는 객체는 **클리핑**되어 제거된다.

#### ④. 화면 매핑
*Screen Mapping*
클리핑 과정을 통과한 객체는 메모리에 저장되고, **화면 매핑**을 통해 3d 좌표가 2d 화면 좌표로 변환된다.
즉, 이 단계에서 3d 객체의 2d 표현이 결정된다. (~~이 과정은.. 래스터화 단계에 포함되어야 하는 거 아닐까?~~)

![[Pasted image 20250225231344.png]]

---
### (3) 래스터화 단계
*Rasterization stage*
지오메트리 처리 단계를 거친 객체는 2d 좌표를 갖게 된다. 이 단계에서는 객체가 화면의 어떤 픽셀에 나타날 지 결정하며, 이를 **래스터화**라고 한다.
래스터화는 다음 두 단계로 진행된다:
1. **삼각형 설정(Triangle Setup)**: 삼각형의 경계(Edge)를 정의하는 데이터 구성
2. **삼각형 탐색(Triangle Traversal)**: 경계 내 픽셀을 찾아낸다.

#### ①. 삼각형 설정
*Triangle Setup*
삼각형 경계(`Edge`)에 대한 방정식을 통해 데이터를 수집한다.
이를 바탕으로 픽셀이 어떤 삼각형에 속하는지 찾고, 이들을 매핑한다.

#### ②. 삼각형 탐색
*Triangle Traversal*
삼각형 설정 단계에서 수집한 데이터를 기반으로, 삼각형 내 픽셀을 찾아 **프래그먼트(Fragments)** 라는 그룹으로 묶는다.
여기서 **프래그먼트**는 색상(*Color*)이나 질감(*Material*)을 입힐 픽셀들의 모음이다.

![[Pasted image 20250225233857.png]]

---
### (4) 픽셀 처리 단계
*Pixel processing stage*
픽셀 처리 단계는 이 렌더 파이프라인의 마지막 단계로, **프래그먼트 셰이더 단계(Fragment Shader Stage)** 라고도 불린다.
이 단계에서 각 **프래그먼트(Pixel)** 의 **최종 색상**과 **가시성**이 결정된다.
이전 단계의 데이터(정점 위치, 색상 및 텍스쳐 좌표 등)가 **보간(Interpolation)** 된 후 처리된다.

![[Pasted image 20250301143727.png]]

#### ①. 보간된 데이터 활용
정점 셰이딩에서 계산된 값(예시: 삼각형 정점의 색상이나 텍스쳐 좌표)이 삼각형 내부 픽셀에 맞게 부드럽게 **보간**된다. 예를 들어, 삼각형의 한 정점이 빨간색이고, 다른 정점이 파란색이라면, 사이 픽셀들은 그라데이션처럼 보인다.

#### ②. 최종 색상 계산
각 픽셀에 조명, 텍스쳐, 재질 등의 요소를 적용해 최종 색상을 계산한다. 예를 들어, 조명 각도에 따라 밝기가 달라지거나, 텍스쳐(나무, 금속 등)가 입혀진다.
이 과정은 셰이더 코드가 담당한다.

#### ③. 색상 버퍼로 전송
계산된 픽셀 색상은 **색상 버퍼(Color Buffer)** 라는 메모리 공간으로 전송된다.
이 버퍼는 화면에 표시될 최종 이미지를 저장하며, 이를 통해 화면에 그림이 나타난다.

#### ④. 정리
3d 객체인 `Cube`가 화면에 있다고 가정해보자. 어두운 배경에 45도 각도로 조명을 비춘다면, `Cube` 객체에는 밝은 부분과 어두운 부분이 생긴다.
이 과정에서 텍스쳐와 픽셀 처리를 통해 최종 모습이 완성된다.

---
## 3. 렌더 파이프라인의 종류
*Types of Render Pipeline*
유니티에서 화면에 3d 객체를 그리는 방식은 렌더 파이프라인에 따라 달라진다.

### (1) Built-in RP
유니티의 기본적이자 오래된 렌더링 방식이다.
설정이 간단하고 유연하지만, 최신 그래픽 기술(고급 조명, 셰이딩 등)을 구현하기에는 부족하다.

### (2) Universal RP 
모바일 및 중저사양 기기를 타겟으로 설계된 렌더링 방식으로, **Scriptable Render Pipeline(SRP)** 기반이다.
성능과 그래픽 품질의 균형을 맞춘 옵션이며, 모바일 게임 개발자들이 자주 사용한다.

### (3) High-Definition RP
고사양 PC나 콘솔 게임을 위한 렌더링 방식으로, **SRP** 기반이다.
사실적인 조명, 그림자, 반사 효과 등을 제공하며, 고품질 그래픽을 원할 때 적합하다.

> [!TIP] SRP란..?
> **Scriptable Render Pipeline**은 개발자가 렌더링 과정을 커스터마이징할 수 있게 해주는 기술이다. URP와 HDRP는 이 SRP를 기반으로 만들어졌다.

---
## 4. 렌더 경로
*Render Path*
**렌더 경로**는 렌더 파이프라인 내에서 이미지를 그리는 세부 처리 방식을 결정하며, 특히 조명과 셰이딩 계산에 중요한 역할을 한다. 
유니티의 주요 렌더 경로는 다음과 같다:
1. **포워드 렌더링(Forward Rendering)**: 조명을 즉시 계산, 속도가 빠르고 호환성이 좋아 기본 설정으로 사용
2. **디퍼드 셰이딩(Deferred Shading)**: 조명 계산을 한 번에 처리, 조명이 많은 씬에서 효율적, 고품질 그래픽에 적합
3. **레거시 디퍼드(Legacy Deferred)**
4. **Legacy Vertex Lit**

기본 설정은 포워드 렌더링이다.
렌더 경로를 이해하려면 먼저 조명 모델을 알아야 한다.

---
### (1) 조명 모델
*Lighting Model*
**조명 모델**은 3d 씬에서 객체와 조명(`Directional Light`나 `Point Light` 등)이 상호작용하는 방식을 정의한다. 기본 요소는 다음과 같다:
- **주변 색상(Ambient Color)**: 씬 전체에 균일하게 적용되는 기본 조명
- **확산 반사(Diffuse Reflection)**: 빛이 표면에서 고르게 퍼지는 효과, 기본 색상과 밝기를 결정
- **정 반사(Specular Reflection)**: 빛이 반사되어 하이라이트를 생성하는 효과(금속, 유리 등에서 두드러진다)

이 계산은 정점 셰이더 또는 프래그먼트 셰이더에서 이루어진다.
정점 단위는 빠르지만, 품질이 낮고, 프래그먼트 단위는 느리지만 정밀하다.

---
### (2) 포워드 렌더링
*Forward Rendering*
포워드 렌더링은 유니티의 기본 경로로, 노멀맵, 픽셀 단위 조명, 그림자를 지원한다.
조명 처리는 두 가지 Pass로 나뉜다:

> [!TIP] `pass`란?
> 셰이더에서 `pass`는 **렌더 파이프라인을 한 번 실행하는 단위**를 뜻한다.

#### ① Base Pass
`ForwardBase Light Mode`로 정의되며, 주요 조명(`Directional Lgith`, `Light Probe`, `Globall Illumination`, `Ambient Illumination`, `Skybox` 등)을 처리한다.
1. 가장 밝은 `Directional Light`를 픽셀 단위로 계산
2. 여러 조명 중 **가장 밝은 하나**만 처리
3. 주변 조명 효과 추가

#### ② Additional Pass
`ForwardAdd Light Mode`로, 추가 조명(`Point Light`, `Spot Light`)과 그림자를 처리한다.
Base Pass에서 처리하지 못한 나머지 작업을 여기서 마무리한다.

#### ③ 드로우 콜
*Draw call*
**드로우 콜**은 GPU가 화면에 뭔가 객체를 그릴 때 발생하는 명령이다. 조명이 많을수록 드로우 콜이 증가하며, 성능에 부담을 준다. 
드로우 콜 예시:
- `Sphere` 4개, `Directional Light` 1개:
	1. **Base pass**: `Sphere` 4개 x `Directional Light` 1개 =  4번의 드로우 콜
	2. **Additional Pass**: `Sphere` 4개 x `Shadow` 계산 1회 = 4번의 드로우 콜
- **총 8번의 드로우 콜**이 발생

`Point Light`를 하나 더 추가해보자.
- **Additional Pass**: `x4`와 그림자 계산을 위한 `x4` 추가
- **총 16회의 드로우 콜**이 발생

조명이 늘어날수록 드로우 콜이 급격히 증가한다.
특히 모바일 게임 개발에서는 이를 줄이는 것이 중요하다.

---
### (3) 디퍼드 셰이딩
*Deferred Shading*
**디퍼드 셰이딩**은 3d 객체와 조명을 분리하여 계산한다.
조명을 단일 `Lighting Pass`에서 처리하며, 광원에 영향을 받는 픽셀들만 다룬다.
장점:
- 조명이 많아도 효율적
- 고품질 그래픽 제공
단점 및 제한 사항:
- 픽셀 당 계산량 증가(GPU 부담)
- 하드웨어 요구 사항 제한: *Shader Model 3.0* 이상, *Depth Render Texture*를 지원 그래픽 카드 필요
- 모바일 제한: *OpenGL ES 3.0* 이상이 필요
- 카메라 제한: Perspective(원근) 카메라만 지원하고, ~~Orthographic(직교) 카메라는 사용할 수 없다~~.
(현재 직교에서도 사용 가능)
 
> [!TIP] 디퍼드 셰이더는 어떤 경우에 사용할까?
> 조명이 많고, 고사양 기기를 타겟으로 하는 AAA급 프로젝트 개발에 적합하다.

---
### (4) 렌더 파이프라인 선택 기준
1. 타겟 플랫폼
	- PC/콘솔: HDRP, Built-in RP
	- 모바일: URP, Built-in RP
2. 그래픽 품질
	- 고사양: HDRP (사실적 그래픽)
	- 중간 사양: URP (품질과 성능 균형)
	- 유연성 중시: Built-in RP
3. 셰이더 작성 방식
	- **Shader Graph**: URP와 HDRP 지원, 시각적 노드 편집 가능, 유니티 버전에 깊은 의존
	- **HLSL**: 모든 파이프라인 지원, 코드 기반으로 안정적, 장기적 관점에서 추천

---
## 5. 행렬과 좌표 시스템
*Matrices and coordinate system*
**행렬(Matrix)** 은 3d 공간을 다루는 핵심 도구로, 유니티에선 주로 4x4 행렬을 사용한다.
이를 통해 위치, 회전, 크기 변환이 이루어진다.

```C
UNITY_MATRIX
(
	Xx, Yx, Zx, Tx,
	Xy, Yy, Zy, Ty,
	Xz, Yz, Zz, Tz,
	Xt, Yt, Zt, Tw
);
```

---
### (1) 주요 행렬
- **UNITY_MATRIX_MVP**: 객체 공간 -> 클립 공간
- **UNITY_MATRIX_V**: 월드 공간 -> 뷰 공간
- **UNITY_MATRIX_P**: 뷰 공간 -> 클립 공간
- **unity_ObjectToWorld**: 객체 공간 -> 월드 공간

---
### (2) 좌표 공간
1. **객체 공간(Object Space)**: 객체 자체의 로컬 좌표. 객체의 중심이 `(0, 0, 0)`이 된다.
2. **월드 공간(World Space)**: 씬 전체의 글로벌 좌표. 씬의 원점이 `(0, 0, 0)`이다.
3. **뷰 공간(View Space)**: 카메라 시점의 기준 좌표. 카메라 위치가 `(0, 0, 0)`이 된다.
4. **클립 공간(Clip Space)**: 화면에 투사되기 직전의 좌표. 카메라의 시야 범위 내에서 정규화된 상태이다.

![[Pasted image 20250301170449.png]]

---
### (3) 변환 과정
- **모델 행렬(Model Matrix)**: 객체의 위치, 회전, 크기를 정의
- **뷰 행렬(View Matrix)**: 카메라의 위치, 방향을 반영
- **투영 행렬(Projection Matrix)**: 3d를 2d 화면에 투사

예를 들어, `UNITY_MATRIX_MVP`는 모델(*M*), 뷰(*V*), 투영(*P*) 행렬을 한 번에 곱한 것으로, 정점을 객체 공간에서 클립 공간으로 변환한다.

![[Pasted image 20250301170013.png]]

정점은 `(x, y, z, w)` 형태의 **동차 좌표계(Homogeneous Coordinate System)** 로 표현된다.
- `w = 1`: 공간의 한 점(Point)
- `w = 0`: 방향 (Vector)
  
이를 통해, 점과 방향을 하나의 행렬로 처리할 수 있다!

![[Pasted image 20250301164930.png]]

---
