---
tags:
  - Unity
  - Shader
date: 2025-02-23
---

> [!info] 머리말
> "The Unity Shaders Bible." 이라는 책을 읽고 정리한 내용이다.

---
##  1. 폴리곤 객체의 속성
*Properties of a **polygonal** object*
**폴리곤**은 선분으로 둘러쌓인 닫힌 평면 도형이다.
어원부터가 그리스어 *πολύγωνος*에서 유래됐다고 한다. (*Poly(많은) + Gnow(각도)  = Polygon*)

![[Pasted image 20250223232155.png]]

**기본 타입(Primitive)** 은 폴리곤으로 구성된 **3차원 지오메트릭 객체**이다.
유니티(블렌더, 마야 등)에서 자주 볼 수 있는 **구(Spheres)**, **상자(Boxes)**, **사각형(Quads)**, **원기둥(Cylinders)**, **원통(Capsules)** 등이 바로 기본 타입이다.

이 객체들은 생김새는 전부 다르지만, 공통적인 속성이 있다.
- **정점(Vertices)**: 객체의 모양을 형성하는 점들
- **접선(Tangents)**: 표면의 방향을 나타내는 벡터
- **법선(Normals)**: 표면과 수직 방향을 나타내는 벡터
- **UV 좌표(UV coordinates)**: 3d 객체에 텍스쳐를 입히기 위한 2D 좌표
- **색상(Color)**: 객체의 색상 정보

> [!TIP] 위 데이터는 **메쉬(Mesh)** 라는 데이터 타입 내에 저장된다.
> 그러므로, 셰이더를 통해 이 속성들에 접근하여 객체의 모양이나 색을 자유롭게 변경할 수 있다.
> 예를 들어, 모델링 툴을 통해 정점 위치를 조정하여 객체를 변형시킬 수 있다.

![[Pasted image 20250223233400.png]]

---
### (1) 정점
*Vertices*
정점은 2d나 3d 공간에서 객체의 표면을 정의할 수 있는 "**점(Point)**"의 집합이다.
즉, 객체의 모양을 만드는 가장 기초 단위이다.

정점에는 두 가지 중요한 특징이 있다:
- **Transform 컴포넌트의 자식이다.**
- **부피(Volume)** 중심에 따라 정의된 "위치"
> [!TIP] 정점은 객체 전체의 부피를 기준으로 위치가 정의된다!

Transform 노드는 객체의 **중심점(Pivot)** 에 따라 *위치(position)*, *회전(rotation)*, *크기(scale)* 를 설정하고, 그 아래 붙은 Shape 노드에는 정점의 위치와 같은, **지오메트리 속성(Geometry Attribute)** 이 들어있다.

따라서 Transform을 통해 객체의 **정점 집합(Vertex Set)** 을 이동, 회전 및 크기를 조정할 수 있다.
여기서 HLSL(셰이더)의 `POSITION[n]`시맨틱을 통해 정점의 위치(*부피와 관련된*) 정보를 가져올 수 있다.

> [!TIP] 시맨틱이란?
> **Semantic**: 해당 코드가 어떤 의미를 지니고, 전체 프로그램 중 어떤 역할을 하는가를 나타내는 것.
> 여기서 관점은 프로그램이 아닌, "**해당 코드**"이다. 예를 들어, `POSITION`은 정점의 위치를 의미한다.
> 즉,`foo(100)` -> `GetDamaged(100)` 이런 식으로 적어야 "시맨틱"하게 작성했다~ 라 할 수 있다.

![[Pasted image 20250224001757.png]]

---
### (2) 법선
*Normal*
**법선(Nomal)** 은 폴리곤 표면의 수직 벡터이다. 
대체로, 표면이 어느 방향을 향하고 있는지 나타내는 화살표로 법선은 표현된다.
이는 **면(Face)** 또는 **정점(Vertex)** 의 방향을 결정하는데 사용된다.

> [!TIP] 표면의 방향을 왜 알아야 할까?
> 3d 모델링 툴을 보면, 법선을 가시적으로 볼 수 있게끔 하는 옵션이 있다.
> 모델러는 법선을 통해 해당 표면이 제대로 된 방향을 보고 있는지 여부를 파악할 수 있다.
> 만약 법선이 안쪽을 향하고 있다면... 객체는 뒤집혀 보이게 된다.

![[Pasted image 20250224010555.png]]

---
### (3) 접선
*Tangent*
**접선(Tangent)** 은 3d 객체 표면의 UV 좌표 중, `U`방향(가로 방향)을 따르는 정규화된 벡터이다.
(UV좌표에 대해 미리 설명하자면, 텍스쳐를 입힐 때 사용하는 2d 좌표이다. 접선은 그 중 가로 방향을 나타내는 것이다.)

접선은 법선과 함께, 표면의 방향을 나타내는 데 사용된다. 법선이 수직 방향을 가리킨다면, 접선은 가로 방향을 가리킨다. 

![[Pasted image 20250224220012.png]]
- **빨강**: Tangent (접선)
- **파랑**: Normal (법선)
- **초록**: Binormal (종법선)

> [!WARNING] Binormal은 셰이더를 통해 지원되지 않는다.
> 그러므로, Normal과 Tangent를 통해 계산해야 한다.

---
### (4) UV 좌표
*UV Coordinates*
**UV 좌표**는 3d 객체에 2d 텍스쳐를 입히기 위해 존재하는 좌표이다.
쉽게 설명하자면, 3d 모델링을 2d 공간에 펼쳐서, 텍스쳐를 붙이는 작업을 할 수 있는 공간이다.
여기서, UV 좌표는 텍스쳐 맵 위에서 메쉬의 각 정점에 해당하는 **텍셀(Texel)** 을 제어하는 기준점 역할을 한다. 

> [!TIP] 텍셀이란?
> 말 그대로 블렌더의 UV 편집기를 누르면, 3d 모델이 펼쳐진다.
> 거기서 각 기준점 역할을 하는 정점이 있다. 이를 **텍셀(Texel)** 이라 부른다.

여기서 UV 좌표 위에 정점을 배치하는 작업을 **UV 매핑**이라 한다.
- 객체 메쉬를 2차원 공간에 펼치는 작업
- 펼친 메쉬를 텍스쳐 위에 올려, 편집 및 구성

셰이더에서는 UV 좌표를 텍스쳐를 입히거나, 단순히 정보만을 저장하는 데 활용할 수 있다.

![[Pasted image 20250224222501.png]]

> [!TIP] 우측이 바로 UV 좌표이다. 여기서 가로축이 `U`, 세로축이 `V`를 의미한다.

UV 좌표는 `0.0f ~ 1.0f` 사이의 범위를 갖는다.
`0.0f`는 시작점을 의미하고, `1.0f`는 끝점을 의미한다.

![[Pasted image 20250224222820.png]]

---
### (5) 버텍스 컬러
*Vertex Color*
**버텍스 컬러**는 정점에 저장된 색상 정보이다.
기본 값은 흰색 (RGBA 채널 값 모두 `1.0f`)이지만, 조명 및 다른 색상과 계산되기 때문에 최종 색상은 달라질 수 있다.

버텍스 컬러를 사용하면, 정점 단위로 색상을 조절할 수 있다.
이를 통해 그라데이션과 같은 효과를 만들 수도 있다!

![[Pasted image 20250224223132.png]]

---
## 2. 렌더 파이프라인 아키텍쳐
*Render Pipeline Architecture*
유니티에는 세 가지 렌더 파이프라인이 있다.
1. **Built-in RP**: 기본 렌더 파이프라인
2. **Universal RP**: 범용적인 작업에 용이하다. (옛 이름은 **Lightweight RP**)
3. **High-Definition RP**: 고품질 그래픽 작업용

> [!INFO] 파이프라인이란?
> **파이프라인**은 하나의 거대한 작업을 수행하기까지의 과정을 의미한다.

> [!TIP] 그렇다면.. 렌더 파이프라인이란?
> **렌더 파이프라인**은 3d 객체가 컴퓨터 화면에 그려질 때 까지의 전체 과정을 의미한다.

![[Pasted image 20250224223832.png]]

각 파이프라인은 고유한 특성이 있다.
어떤 파이프 라인을 사용하느냐에 따라 재질(Material), 조명(Light), 텍스쳐(Texture) 등의 셰이더 동작이 달라진다.
즉, 파이프라인 작업 하나로 인해, 객체의 모습과 성능이 완전히 바뀔 수 있다는 뜻이다.

일반적으로 실시간 렌더링 엔진들의 렌더 파이프라인은 다음 4가지 단계를 거친다.
1. **애플리케이션 단계(Application Stage)**
2. **지오메트리 처리 단계(Geometry Procesisng Phase)**
3. **레스터화 단계(Rasterization Stage)**
4. **픽셀 처리 단계(Pixel Processing Stage)**

![[Pasted image 20250224225008.png]]

---
### (1) 애플리케이션 단계
*Application Stage*
**애플리케이션 단계**는 **CPU**에서 시작된다. 여기서는 씬에서 발생하는 대부분의 작업을 처리한다.
- 충돌 감지(Collision Detection)
- 텍스처 애니메이션(Texture Animation)
- 키보드 및 마우스 입력 처리
또한, 메모리에 저장된 데이터를 읽어와 기본 타입(Primitive)로 변환한다.
이 단계가 끝나면, 데이터는 "지오메트리 처리 단계"로 넘어가서, 행렬 연산을 통해 정점의 위치 변환이 일어난다! (Transform 변수가 만들어진다는 뜻이다.)

![[Pasted image 20250224230005.png]]

---
### (2) 지오메트리 처리 단계
*Geometry processing phase*
컴퓨터 화면에 보이는 이미지는 GPU가 CPU의 요청을 받아 만드는 것이다.
GPU가 CPU의 요청을 받아 이미지를 그리는 과정은 크게 두 단계로 나눌 수 있다:
1. 렌더링 상태 설정(Configuration)
2. 화면에 객체 그리기

> [!TIP] 렌더링 상태 설정
> 지오메트리 처리부터 픽셀 처리까지의 계획을 이 때 세운다.

그 중, 지오메트리 처리 단계는 GPU에서 시작되어 객체의 정점을 처리하는 단계이다. 다음 네 가지 과정을 거친다:
1. **정점 셰이딩(Vertex Shading)**: 정점 위치 계산
2. **투영(Projection)**: 3d를 2d로 투사
3. **클리핑(Clipping)**: 씬(시야?) 밖의 객체 제거
4. **화면 매핑(Screen Mapping)**: 2d 스크린 좌표 변환

![[Pasted image 20250224231836.png]]

#### ① 정점 셰이딩
*Vertex Shading*
이전 단계인 애플리케이션 단계에서 만들어진 기본 타입(대부분 삼각형을 사용한다!)을 갖고 정점 셰이딩을 시작한다. 이 과정은 **정점 셰이더 단계(Vertex Shader Stage)** 라고도 부른다.
정점 셰이딩은 이렇게 진행된다:
1. 객체의 정점 위치를 계산한다.
2. 화면에 투사할 수 있도록, 좌표계를 변환한다.
이 때, `Normal`, `Tangent`, `UV Coord` 같은 속성도 다음 단계로 전달할 수 있다!

#### ②-③. 투영 및 클리핑
*Projection, Clipping*
이 과정은 카메라 설정이 원근인지, 직교인지에 따라 달라진다.
여기서 렌더링은 카메라의 시야(Frustum) 내에서만 발생한다고 이해하면 된다!
여기서 카메라의 시야를 **뷰 공간(View Space)** 라고 한다.

카메라 시야 밖에 있거나, 걸쳐 있는 객체는 **클리핑**되어 잘려나가고, 렌더링에서 제외된다.

#### ④. 화면 매핑
*Screen Mapping*
클리핑 과정을 통과한 객체는 메모리에 저장되고, **화면 매핑**을 통해 3d 좌표가 2d 화면 좌표로 변환된다.
다시 말해, 이 단계를 거쳐 3d 객체가 2d로는 어떻게 보일지 결정된다.

![[Pasted image 20250225231344.png]]

---
### (3) 래스터화 단계
*Rasterization stage*
지오메트리 처리 단계를 거친 객체는 2d 좌표를 가지게 된다.
이제 이 객체가 화면의 어떤 픽셀에 나타날 지를 찾아야 한다. 이 과정을 바로 **래스터화**라 한다.

래스터화 단계는 다음 두 단계로 진행된다:
1. **삼각형 설정(Triangle Setup)**: 삼각형의 경계(Edge)를 정의하는 데이터 구성
2. **삼각형 탐색(Triangle Traversal)**: 경계 안의 픽셀을 찾아낸다.

#### ①. 삼각형 설정
*Triangle Setup*
삼각형 경계(윤곽선?, `Edge`)에 대한 방정식을 통해, 데이터를 수집한다.
이 데이터를 바탕으로 어떤 픽셀이 어떤 삼각형과 매핑되는 지를 찾을 수 있다.

#### ②. 삼각형 탐색
*Triangle Traversal*
위 삼각형 설정 단계에서 수집한 데이터를 바탕으로, 해당 삼각형 내에 있는 픽셀을 찾아 `Fragments`라는 이름의 그룹으로 묶는다.

여기서 `Fragments`는 색을 입힐 `Pixel`들의 모음이다. 이 `Fragments`는 다음 단계에서 색이나 질감을 입히는 데 사용한다.

![[Pasted image 20250225233857.png]]

---
### (4) 픽셀 처리 단계
*Pixel processing stage*
픽셀 처리 단계는 이 렌더 파이프라인 과정의 마지막 단계이다.
이 단계는 흔히 "**프래그먼트 셰이더 단계(Fragment Shader Stage)**"라 하는데, 그 이유는 여기서 각 **픽셀(프래그먼트)** 의 **최종 색상**과 **가시성**을 결정하기 때문이다.
이전 단계에서 처리된 데이터(정점 위치, 색상, 텍스처 좌표 등)이 이 단계로 넘어와서, 픽셀 단위로 **보간(Interpolation)** 된 후, 작업이 시작된다.

![[Pasted image 20250301143727.png]]

#### ①. 보간된 데이터 활용
이전, 정점 셰이딩을  통해 계산된 값들이 (예를 들면, 삼각형의 세 정점에 있는 색상이나 텍스쳐 좌표) 삼각형 내부 모든 픽셀에 맞게 부드럽게 보간된다.
만약 삼각형의 한 정점이 빨간색이고, 다른 정점이 파란색이라면, 그 사이 픽셀들은 색이 섞여서 그라데이션처럼 보이게 된다!

#### ②. 최종 색상 계산
각 픽셀마다 고유의 조명, 텍스쳐, 머테리얼 같은 요소를 적용해서 최종 색상을 결정한다. 
예를 들어, 조명이 객체에 닿는 각도에 따라 밝기가 달라진다거나, 텍스쳐 이미지가 (나무, 금속 등) 픽셀에 입혀질 수 있다.
여기서 셰이더 코드가 "이 픽셀은 어떤 색상이어야 할 지"를 계산한다.

#### ③. 색상 버퍼로 전송
위 과정을 거쳐 계산된 픽셀의 색상은 "**색상 버퍼(Color Buffer)**"라는 메모리 공간으로 보내진다.
여기서 색상 버퍼는 화면에 표시될 최종 이미지를 저장하는 곳이다. 즉, 이 데이터를 바탕으로 화면에 그림이 나타나는 것이다!

#### ④. 정리
3d 객체인 `Cube`가 화면에 있다고 가정해보자. 만약 어두운 배경에 45도 각도로 조명을 비춘다면, `Cube` 객체에는 밝은 부분과 어두운 부분이 생길 것이다.
여기서 `Cube`의 텍스쳐에는 각 상황에 맞는 픽셀을 위 과정을 통해 입혀서, 최종적으로 우리가 볼 수 있는 그 모습을 만들게 된다.

---
## 3. 렌더 파이프라인의 종류
*Types of Render Pipeline*
유니티에서 화면에 3d 객체를 그리는 방식은 "렌더 파이프라인"에 따라 달라진다.

### (1) Built-in RP
유니티의 가장 기본적이고, 오래된 렌더링 방식이다.
설정이 간단해서 쉽게 사용할 수 있고, 유연성이 뛰어나지만 최신 그래픽 기술을 (고급 조명 및 셰이딩 작업) 수행하기에는 많이 부족할 수 있다.

### (2) Universal RP 
모바일이나 중, 저사양 기기를 타겟으로 설계된 렌더링 방식이다. 
"**Scriptable Render Pipeline(SRP)**"라 불리는 유니티의 최신 기술을 기반으로 만들어졌다.
이는 성능과 그래픽 품질 사이에서 균형을 잘 맞춘 옵션이다. 모바일 게임 개발자들에게 큰 인기를 끌고 있다.

### (3) High-Definition RP
고사양 PC나 콘솔 게임처럼 고품질 그래픽이 필요할 때를 위한 렌더링 방식이다.
이 역시 SRP 기반이고, 사실적인 조명, 그림자 및 반사 효과 등의 기능을 제공한다.
뛰어난 그래픽 퀄리티를 만들고 싶을 때 사용하면 된다.

> [!TIP] SRP란..?
> **Scriptable Render Pipeline**은 개발자가 렌더링 과정을 자유롭게 커스터마이징 할 수 있게 해주는 기술이다. URP와 HDRP는 이 SRP를 기반으로 만들어진 렌더 파이프라인이다.

---
## 4. 렌더 경로
*Render Path*
**렌더 경로**란, 렌더링 파이프라인 안에서 구체적으로 "어떻게 이미지를 그릴지" 결정하는 세부 처리 방식이다.
특히 조명과 셰이딩 계산 방식을 정의하는 데 아주 중요한 역할을 한다.

유니티에서 지원하는 주요 렌더 경로는 다음과 같다:
1. **포워드 렌더링(Forward Rendering)**: 기본 렌더 경로로, 조명을 즉시 계산하여 픽셀 색상을 결정한다. 속도가 빠르고, 그래픽카드 호환성이 좋아서 널리 사용된다.
2. **디퍼드 셰이딩(Deferred Shading)**: 조명 계산을 한 번에 몰아서 처리하는 방식. 특히 조명이 많은 씬에서 사용하면 효율적이다. (이런 특성으로 인해, 고퀄리티 그래픽에 적합하다)
3. **레거시 디퍼드(Legacy Deferred)**
4. **Legacy Vertex Lit**

유니티의 기본 설정은 포워드 렌더링이다.
위 렌더 경로를 자세히 알아보기 전에, 조명 모델에 대해 먼저 알아보도록 하자.

---
### (1) 조명 모델
*Lighting Model*
**조명 모델**은 3d 씬에서 객체와 조명이 (`Directional Light`나 `Point Light`) 상호작용하는 방식을 결정한다.
기본적인 조명 모델은 세 가지 요소가 합쳐져서 나타난다.
- **주변 색상(Ambient Color)**: 씬 전체에 깔리는 기본 조명. 모든 물체에 균일하게 적용된다. 
- **확산 반사(Diffuse Reflection)**: 빛이 물체 표면에서 고르게 퍼지는 효과. 물체의 기본 색상과 밝기를 결정하는 데 사용된다.
- **정 반사(Specular Reflection)**: 빛이 반사돼서 반짝이는 하이라이트를 만드는 효과. 금속 및 유리 같은 재질에서 잘 나타난다.

이 조명들의 계산은 **정점 셰이더**나 **프래그먼트 셰이더**에서 이루어질 수 있다. 
여기서 정점 단계로 계산하면 빠르지만, 품질이 낮고,
프래그먼트 단위로 계산하면 느리지만, 더 정밀한 결과가 나타난다.

---
### (2) 포워드 렌더링
*Forward Rendering*
포워드 렌더링은 유니티의 기본 렌더 경로이다. 
여기서는 노멀맵, 픽셀 단위 조명, 그림자와 같은 기능을 지원해서 꽤 유용하게 사용할 수 있다.
포워드 렌더링에서는 셰이더가 두 가지 **pass**를 통해 조명을 처리한다.

> [!TIP] 여기서 `pass`란?
> 셰이더에서 `pass`는 **렌더 파이프라인 과정을 한 번 실행하는 단위**를 뜻한다.

포워드 렌더링 방식에는 다음 두 가지 패스가 사용된다.
1. **Base Pass**
2. **Additional Pass**

#### ①. Base Pass
`ForwardBase Light Mode`로 정의된다.
씬에서 가장 밝은 `Directional Lgith`, `Light Probe`(간접 조명 데이터), `Globall Illumination`, `Ambient Illumination`, `Skybox` 등을 처리한다. 
즉, 주요 조명들은 모두 여기서 계산이 들어가는 것이다:
1. 씬에서 가장 밝은 `Directional Light`를 픽셀 단위로 계산한다.
2. 만약 `Directional Light`가 여러 개 있다면, 가장 밝은 하나만이 Base Pass에서 계산된다.
3. `Light Probe`나 `Skybox`에서 오는 주변 조명도 모두 여기에 포함되어 간접적인 빛 효과를 더해준다.

#### ②. Additional Pass
`ForwardAdd Light Mode`로 정의된다.
그리고 추가적인 조명이나 (`Point Light`, `Spot Light`), 그림자를 처리한다.
Base Pass에서 처리하지 못한 나머지 작업을 여기서 마무리한다고 보면 된다:
1. 여러 개의 조명이 있는 씬이 있다고 가정해보자.
2. Base Pass 단계에서 가장 밝은 주요 조명 하나만을 계산한다.
3. 나머지 조명들은 모두 Additional Pass에서 추가로 계산이 된다.

#### ③. 드로우 콜
*Draw call*
**드로우 콜**은 GPU가 화면에 뭔가 그릴 때 발생하는 명령이다.
조명이 많아질 수록 드로우 콜이 많이 발생하게 된다. (많으면 많을 수록 성능에 부담이 간다)
다음 상황을 생각해보자:
- 씬에 `Sphere` 4개와 `Directional Light` 1개가 있다.
	1. Base pass: `Sphere` 4개 x `Directional Light` 1개 =  4번의 드로우 콜
	2. Additional Pass: `Sphere` 4개 x `Shadow` 계산 1회 = 4번의 드로우 콜
- 결과적으로 총 8번의 드로우 콜이 발생한다.

만약 위 상황에서 `Point Light`를 하나 더 추가한다고 하면 어떻게 될까?
- `Point Light`가 하나 추가된다면, Additional Pass에는 `x4`와 그림자 계산을 위한 `x4`가 또 들어가게 된다.
- 그러면 총 `68`회의 드로우 콜이 발생한다는 계산이 나온다.

즉, 조명이 많으면 많을 수록 **드로우 콜**이 비약적으로 증가한다는 것을 알 수 있다.
이는 치명적인 성능 저하를 유발할 수 있다. 
특히 모바일 게임 개발에 있어서는 **드로우 콜**을 줄이는 것이 매우 중요하다.

---
### (3) 디퍼드 셰이딩
*Deferred Shading*
**디퍼드 셰이딩**은 포워드 렌더링과 다른 접근법을 사용한다.
3d 객체와 조명을 분리하여 처리하는데, 모든 조명을 단 한 번의 `Lighting Pass`에서 계산한다. 또한 광원에 영향을 받는 픽셀들만을 다룬다.
이 방식은 조명이 많은 상황에서 조명을 효율적으로 처리할 수 있다는 특징이 있다.

#### 


이 렌더 경로는 3d 객체와 조명을 분리하여, 씬의 각 광원을 계산하는 `lighting pass`가 단 하나만 존재함을 보장하며, 해당 광원의 영향을 받는 픽셀에 대해서만 계산되도록 한다.
이는 여러 객체에 영향을 미치는 상당한 양의 빛을 생성할 수 있어 최종 렌더링의 충실도를 향상시키지만, 명목상 GPU의 픽셀 당 계산을 증가시킨다. (유리한 측면...? 그런 뜻으로 적은 건가)

디퍼드 셰이딩은 여러 광원을 계산하는 데 있어 포워드보다 우수하지만, 몇 가지 제한 사항이 있다.
여러 렌더 타겟이 있어야 하고, Shader Model 3.0 이상을 지원해야 하고, Depth render texture를 지원하는 그래픽카드가 필요하다.
모바일 기기의 경우, OpenGL ES 3.0 이상을 지원하는 디바이스에서만 작동한다.
또한 원근(Perspective) 카메라가 있는 프로젝트에서만 사용할 수 있다. 디퍼드 셰이딩은 Orthographic 투영은 지원하지 않는다.

---
### (4) 어떤 렌더 파이프라인을 고를지
예전엔 Built-in RP만 있었기에, 2d 또는 3d 프로젝트를 시작하는 것이 매우 쉬웠다.
지금은 다음과 같은 요소를 고려해야 한다:
1. PC는 모바일 기기나 콘솔보다 컴퓨팅 성능이 뛰어나다. 만약 비디오 게임이 하이엔드 기기를 대상으로 하는 경우에는 High-Definition 및 Built-in RP를 사용할 수 있다.
2. 만약 비디오 게임을 중간 해상도 정도의 그래픽으로 제작하려는 경우, Universal RP나 Built-in RP를 사용할 수 있다.
어떻게 두 경우 모두에 Built-in RP를 사용할 수 있을까?

요즘의 Built-in RP는 훨씬 더 유연하기 때문에, 더 기술적인 작업이 가능하다. 또한 사전 최적화가 필요하지 않다. High-Definition RP는 고사양 그래픽을 생성하도록 사전 최적화가 되어 있고, Universal RP는 중간급 그래픽을 생성하도록 사전 최적화가 되어 있다.

렌더 파이프라인을 선택할 때 중요한 요소는 바로 셰이더이다. 일반적으로 High-Definition 및 Universal RP 모두 **셰이더 그래프**를 통해 생성된다.

셰이더 그래프 방식의 긍정적인 측면은 HLSL로 코드를 작성할 필요 없고, 노드를 통해 시각적으로 셰이더를 제작할 수 있다는 점이 있다.
대신 제작 중, 유니티 버전을 올리려는 경우 셰이더 그래프의 내용이 크게 바뀌어 컴파일이 중단될 가능성이 매우 높다.

유니티에서 셰이더를 생성하는 가장 좋은 방법은 HLSL을 사용하는 것이다.
이렇게 하면, 프로그램이 다른 렌더 파이프라인에서 컴파일되고, 유니티 업데이트와 관계 없이 계속 작동할 수 있기 때문이다.
이 개념은 나중에 HLSL 파트에서 더 자세히 알아보도록 하자.

---
## 5. 행렬과 좌표 시스템
*Matrices and coordinate system*
셰이더를 만들 때 자주 등장하는 개념 중 하나는 행렬이다.
행렬은 특정 산술 규칙을 따르는 숫자 요소의 목록으로, 컴퓨터 그래픽스에서 자주 사용된다.

유니티에서 행렬은 공간 변환을 나타낸다. 종류는 다음과 같다:
- UNITY_MATRIX_MVP
- UNITY_MATRIX_MV
- UNITY_MATRIX_V
- UNITY_MATRIX_P
- UNITY_MATRIX_VP
- UNITY_MATRIX_T_MV
- UNITY_MATRIX_IT_MV
- unity_ObjectToWorld
- unity_WorldToObject
이들은 모두 4x4 행렬에 해당한다. (4개의 행과 4개의 열로 이루어진 숫자 값에 해당)

```C
UNITY_MATRIX
(
	Xx, Yx, Zx, Tx,
	Xy, Yy, Zy, Ty,
	Xz, Yz, Zz, Tz,
	Xt, Yt, Zt, Tw
);
```

"*I.i 정점*"에서 설명한 것처럼, 3d 객체에는 기본적으로 두 개의 노드가 있다.
Maya에서는 이를 Transform과 Shape라 하며, 둘 다 오브젝트의 중심 위치를 기준으로 정점으ㅢ 위치를 정의하는 **객체 공간(Object Space)** 에서 정점의 위치를 계산하는 역할을 담당한다.

객체의 각 정점의 최종 값에는 **모델 행렬(UNITY_MATRIX_M)** 이라는 행렬이 곱해지며, 이를 통해 `Transform`, `Rotation`, `Scale` 값을 수정할 수 있다.
이렇게 객체가 수정될 때마다 모델 행렬이 업데이트된다.

이 과정이 이루어지는 과정을 알아보자. 우선, 씬에 위치한 큐브를 변형해보자.
먼저 중심을 기준으로 (0.5x, -0.5y, -0.5z, 1.0w) 위치에 있는 큐브의 정점을 가져오자.

> [!TIP] W 채널의 의미
> `vectors`와 `points`를 균일하게 처리할 수 있는 `homogeneous`라는 좌표계에 해당한다.
> 행렬 변환에 있어 W 좌표는 0이나 1이다.
> 만약 W좌표가 **1이면, 공간의 한 점**을 나타내고, **0이라면 방향**을 나타낸다.

![[Pasted image 20250301164930.png]]
여기서 M은 Identity Matrix를 의미하고, 행렬 기본 값을 나타낸다.

행렬에 있어 고려해야 할 한 가지는, 첫 번째 행렬의 행 수가 두 번째 행렬의 열 수와 같을 때만 곱셈을 수행할 수 있다는 것이다. 이미 알려진 바와 같이, 이 모델 행렬은 4x4이고, 정점의 `position`은 4x1이다.

모델 행렬의 열 수는 정점 `position`의 행 수와 같다. 이 둘을 곱하면 4x1 모양의 새 행렬이 생긴다.
즉, 이렇게 새로운 정점 위치를 정의할 수 있게 된다. 이 곱셈 프로세스는 오브젝트의 모든 정점에 대해 발생하며, 이는 **정점 셰이더 단계(Vertex Shader Stage)** 에서 수행된다.

지금까지는 **객체 공간**에서 객체 본인이 중심이 된 정점 위치를 의미했다.
그렇다면, 월드 공간, 뷰 공간 또는 클립 공간은 무엇을 의미할까?

월드 공간은 월드의 중심에 따른 정점의 위치, 즉, 씬의 **그리드 시작점(0x, 0y, 0z, 1w)** 과 객체의 정점 위치 사이의 거리에 해당한다.

좌표를 객체 공간에서 월드 공간으로 변환하기 위해선, `unity_ObjectToWorld`를 사용하면 된다.

뷰 공간은 카메라 뷰를 기준으로, 객체의 정점 위치를 나타낸다.
월드 공간에서 뷰 공간으로 좌표를 변환하기 위해선, `UNITY_MATRIX_V` 행렬을 사용하면 된다.

![[Pasted image 20250301170013.png]]

마지막으로 투영 공간(Projection Space)라고도 부르는 클립 공간(Clip Space)은 카메라의 프러스텀에 대한 객체의 정점 위치를 나타낸다.
따라서 이 요소는 `Near Clipping Plane`, `Far Clipping Plane`, `Field of View`의 영향을 받는다.

좌표를 뷰 공간에서 클립 공간으로 변환하려면, `UNITY_MATRIX_P` 행렬을 사용하면 된다.

![[Pasted image 20250301170449.png]]

지금까지 서로 다른 공간 좌표에 대해 개념적인 수준에서 이야기했지만, 변환 행렬이 무엇을 가리키는지 명확하게 정의하진 않았다.

예를 들어, 내장 셰이더 변수 `UNITY_MATRIX_MVP`는 세 가지 다른 행렬의 곱셈을 나타낸다. `M`은 모델 매트릭스, `V`는 뷰 매트릭스, `P`는 투영 매트릭스를 나타낸다.
이 행렬은 주로 객체 정점을 객체 공간에서 클립 공간으로 변환하는데 사용된다.
3d 객체는 3d 환경에서 생성된 반면, 투사될 컴퓨터 화면은 2d이므로, 객체를 한 공간에서 다른 공간으로 꼭 변환해야 한다.

이 부분은 추후 정점 셰이더 스테이지의 `UnityObjectToClipPos(VRG)` 함수를 사용할 때 더 자세히 살펴볼 것이다.

---


